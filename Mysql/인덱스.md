### 인덱스란?
- DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 오래 걸리기 때문에 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 주는것이다.
- 책에 비유하면 찾아보기 or 색인으로 설명된다.

### 장단점
- 장점
    - 인덱스를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리 가능하다.
- 단점
    - 데이터가 저장될 때마다 해당 값을 정렬을 해야하기 때문에 INSERT, UPDATE, DELETE 처리는 느려진다. 
    - 인덱스는 하나의 테이블을 생성해 값을 저장하고 사용하기 때문에 다른 테이블에 의존적인 새로운 테이블이 생성된다.

### 인덱스를 어떻게 설정해야할까?
- 검색에 최적화된 기능이기 때문에 삽입,삭제,수정이 자주 일어나는 비즈니스 로직 or 사용 용도에 따라 인덱스 사용 여부를 고민해야한다.
- 무조건 많이 설정하는 것이 검색 속도 향상을 시켜주진 않는다.
- 데이터베이스 메모리를 사용하여 테이블 형태로 저장되므로 개수와 저장공간은 비례하게된다.
- 조회시 자주 사용하거나 고유한 값을 위주로 인덱스를 설정하는 것이 좋다.
- 인덱스는 테이블당 보통 3~5개가 적당하다.

### 인덱스를 설정난 후 동작과정
1. 인덱스 테이블에서 where 절에 포함된 값을 찾는다.
2. 해당 값의 테이블 pk(ex) id)를 가져온다.
3. 가져온 pk값으로 원본 테이블에서 값을 조회에 온다.
---

### B-Tree 인덱스
- B-Tree는 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있다. 전문 검색과 같은 특수한 요건이 아닌 경우 대부분 인덱스는 거의 B-Tree 인덱스를 사용한다.
- 구조
    - 최상위에 하나의 루트노드가 존재한고 그 하위에 자식 노드가 붙어있는 구조이다. 트리 구조에 가장 하위에 있는 노드를 리프노드라고 하고 트리구조에서 루트노드,리프노드가 아닌 중간에 있는 노드를 브랜치 노드라고 한다. ex) 루트 노드 -> 브랜치 노드 -> 브랜치 노드 -> 리프 노드
- 인덱스의 리프노드는 항상 실제 데이트 레코드를 찾아가기 위한 주소 값을 가지고 있다.

### B-Tree 인덱스의 가용성과 효용성
- 작업 범위를 결정하는 조건이 많을 수록 쿼리의 처리 성능을 높이지만 체크 조건이 많다고 해서 쿼리의 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 많들 때가 많다.

### B-Tree 인덱스를 사용할 수 없는 대표적인 경우
- NOT-EQUAL 비교("<>","NOT IN", "NOT BETWEEN","IS NOT NULL")
- LIKE '%??' 형태로 문자열 패턴이 비교되는 경우
- 데이터 타입이 서로 다른 비교
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우

### R-Tree 인덱스
- 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스이다. 일반적으로는 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다. 
- 포함관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용할 수 있다.
- Mysql에서는 거리를 비교하는 함수로는 Contains()나 Intersect()를 주로 사용한다.
