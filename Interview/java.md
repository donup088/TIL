## JVM 구조와 Java의 실행방식
JVM이란?
    - 자바 컴파일러가 .java 파일을 컴파일하면 .class 라는 자바 바이트 코드로 변환시켜준다. 이 때 바이트 코드가 기계어가 아니기 때문에 os에서 바로 실행을 못하는데 이 때 os가 이해할 수 있도록 해석해주는 것이 JVM 이다.
    - JVM을 사용하면 os에 상관없이 같은 코드를 사용할 수 있다.
JVM의 구조
1. Class Loader
    - 자바에 코드를 작성하면 test.java 와 같이 .java 파일이 생성된다. .java 파일을 자바 컴파일러가 컴파일 하면 test.class 같은 .class 파일이 생성된다. 이렇게 생성된 클래스 파일들을 JVM이 운영체제로부터 할당받은 Runtime Data Area로 적재하는 역할을 한다.
2. Execution Engine
    - Class Loader에 의해 메모리에 적재된 클래스들을 기계어로 변경하여 명령어 단위로 실행하는 역할을 한다.
3. Garbage Collector
    - 힙 메모리 영역에 생성된 객체등 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.
4. Runtime Data Area
    - JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.
    - Method Area, Heap Area, Stack Arae, PC Register, Native Method Stack으로 나뉜다.
        1. 메서드 영역(모든 쓰레드가 공유)
            - static 영역, class 영역이라고도 불림
            - 클래스정보, 변수정보, 메서드 정보, static 변수등을 저장 
        2. 힙 영역(모든 쓰레드가 공유)
            - new 키워드로 생성된 객체와 배열이 저장되는 영역
            - GC가 참조되지 않는 메모리를 확인하고 제거하는 영역
        3. 스택 영역
            - 지역 변수, 파라미터, 리턴 값 연산에 사용되는 임시 값등이 생성되는 영역
            - 메서드를 호출할 때마다 개별적으로 스택이 생성되며 종료시 영역에서 해제된다.
            - 하나의 쓰레드는 내부적으로 static,stack,heap 영역을 갖게된다.
        4. PC 레지스터
            - 쓰레드가 생성될 때마다 생성되는 영역으로 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하는 영역
            - 이를 통해서 쓰레드를 돌아가면서 수행할 수 있도록 한다.
        5. Native method stack
            - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역

Java의 실행방식
1. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환
2. Class Loader를 통해 class 파일들을 JVM으로 로딩
3. 로딩된 class 파일들은 Execution Engine을 통해 해석됨.
4. 해석된 바이트코드는 Runtime Data Area에 배치되어 실질적인 수행이 이뤄짐.

## 제네릭이란?
- 제네릭은 자바의 타입 안정성을 담당하고 있다. 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여준다.

## 오버라이딩과 오버로딩
- 오버라이딩은 상위 클래스의 메소드를 재정의하는 것이다. -> 런타임 다형성
- 오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만 매개변수의 타입, 개수가 다르게 구현할 수 있는 것이다. -> 컴파일 타임 다형성
- 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 위해서 @Override를 사용하는 것이 좋다.

## 인터페이스와 추상 클래스
- 추상 클래스 
    - 추상 메소드를 선언하여 상속을 통해서 자식 클래스에서 완성하도록 유도하는 클래스이다. -> 미완성 설계도
    - 추상클래스를 상속받아 기능을 이용하고, 확장시키기 위해 사용
- 인터페이스
    - 다른 클래스를 작성하는데 도움을 주는 목적으로 작성한다. -> 기본 설계도
    - 구현 객체의 같은 동작을 보장하기 위해 사용, 다중상속가능

## static 이란?
- 저장된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조할 수 있다.
- GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재한다. 따라서 너무 많이 사용하면 시스템 성능이 안좋아질 수 있다.

## 원시타입과 참조타입
- 원시타입은 null을 담을 수 없고 참조타입은 가능하다.
- 원시타입은 제네릭을 사용할 수 없고 참조타입은 가능하다.
- 원시타입이 참조타입보다 접근속도가 좋다.
- 원시타입이 참조타입보다 메모리 사용적으로도 효율적으로 사용할 수 있다.
- 박싱, 언박싱
    - 자바 1.5부터 추가된 기능이다.
    ```
    // 오토 박싱
    int i = 10;
    Integer num = i;

    // 오토 언박싱
    Integer num = new Integer(10);
    int i = num;
    ```
    - 편의성을 위해 기능이 제공되고 있지만 내부적으로 추가 연산 작업을 거쳐 성능이 안좋아질 수 있다. 오토 박싱, 언박싱이 일어나지 않도록 동일한 타입 연산이 이루어지도록 해야한다.

## String, StringBuffer, StringBuilder
String과 StringBuffer, StringBuilder의 가장 큰 차이점은 String은 불변이라는 것이다.
```
String s="test";
s=s+"code";
```
위의 예시를 보면 s가 가리키던 값이 testcode로 변하는 것이 아니라 새로운 메모리영역을 가리키게 변경이 되는 것이다. test로 값이 할당되어 있던 메모리 영역은 Garbage로 남아있다가 GC에 의해 사라지게 된다. String 은 불변이기 때문에 문자열 수정을 하게 된다면 새로운 String 인스턴스가 생기게된다.

따라서 변하지 않는 문자열을 자주 읽는 경우는 String을 사용해주면 좋다. 하지만 문자열 수정이 빈번하게 이루어진다면 힙 메모리의 많은 가비지가 생겨 힙메모리 부족으로 성능이 매우 안좋아질 수 있다.

이를 위해서 가변성을 가지는 StringBuffer와 StringBuilder가 생겼다. StringBuffer, StringBuilder는 가변성을 가지기 때문에 동일 객체내에서 문자열 변경이 가능하다.

StringBuffer 와 StringBuilder의 차이는 동기화의 유무다. StringBuffer는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다. 하지만 StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드환경에서 사용하는 것은 적합하지 않다. 하지만 단일쓰레드에서의 성능은 StringBuffer보다 StringBuilder가 더 좋다.

## Checked Exception vs UnChecked Exception
- Checked Exception
    - 반드시 예외처리를 해주어야한다.
    - 스프링 트랜잭션 추상화에서 rollback 대상이 아니다.
    - ex) IOException, SQLException
- UnChecked Exception
    - 예외처리를 하지 않아도 된다.
    - 스프링 트랜잭션 추상화에서 rollback 대상이 된다.
    - RuntimeException 상속
    - ex) NullPointerException, IllegalArgumentException
- 구체적인 UnChecked Exception을 만들고 예외에 대한 메시지를 명확하게 전달하자.

## 직렬화, 역직렬화
직렬화란 메모리를 디스크에 저장하고 네트워크 통신에 사용하기 위한 형식으로 변환하는 것이다.

자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)를 말한다.

JVM의 메모리에서만 상주되어 있는 객체 데이터를 그대로 영속화가 필요할 때 사용된다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송도 가능하다.

- 자바 직렬화의 장점
    - 자바 직렬화는 자바 시스템에 최적화 되어있다.
    - 데이터 타입이 자동으로 맞춰지기 때문에 역직렬화가 되면 기존 객체처럼 바로 사용가능하다.
    - 복잡한 데이터 구조의 클래스라도 직렬화 조건만 지키면 큰 작업없이 바로 직렬화,역직렬화가 가능하다.
- 자바 직렬화 단점
    - 역직렬화를 할 때 클래스 구조가 변경되면 문제가 발생한다.(java.io.InvalidClassException 발생)
    - 이를 해결하기 위해 SerialVersionUID를 정의 해야한다.
    - 간단한 객체라도 2배이상의 용량 차이가 발생하여 메모리 기반 캐시에서는 데이터를 저장할 수 있는 용량의 한계가 있으므로 json 형태와 같은 경량화된 형태로 직렬화하는 것이 좋다.

- 자바 직렬화 사용하는 예시
    1. 서블릿 세션
        - 세션을 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션등을 선택하게 되면 세션 자체가 직렬화 되어 저장되어 전달된다. 따라서 세션에 필요한 객체는 Serializable 인터페이스를 구현해두는 것이 좋다.
    2. 캐시
        - 메모리, 외부 저장소, 파일 등을 저장소를 이용해서 데이터를 객체에 저장한 후 동일한 요청이 오면 DB를 다시 요청하는 것이 아니라 저장된 객체를 찾아서 응답하게 하는 형태를 캐시를 사용한다고 한다. 이렇게 캐시할 부분을 자바 직렬화된 데이터를 저장해서 사용하게 된다.
    3. 자바 RMI
        - 원격 시스템 간의 메시지 교환을 위해 사용하는 자바에서 지원하는 기술이다. 원격 시스템의 메소드를 호출 시 전달하는 메시지를 자동으로 직렬화하고 전달 받는 원격 시스템에서는 메시지를 역직렬화하여 사용한다.

- 자바 직렬화 사용 시 주의할 점
    - 자주 변경되는 데이터에 대해 사용은 지양한다.
    - 긴 만료 시간을 가지는 데이터는 JSON 등 다른 포맷을 사용한다.
    - 역직렬화시 예외가 생길 수 있다는 점을 생각한다.

- SerialVersionUID
    - 자바 직렬화 대상 객체는 동일한 SerialVersionUID를 가지고 있어야한다.
    - SerialVersionUID를 선언하지 않으면 내부적으로 클래스 구조 정보를 이용하여 자동으로 생성된 해시 값이 할당된다. 이 때문에 클래스의 멤버 변수가 추가되거나 삭제되면 SerialVersionUID가 달라진다.

## mutable, immutable 객체
- immutable (불변) 객체
    - ex) String, Boolean, Integer, Long 등이 있다.
    - 값을 수정하면 새로운 인스턴스에 할당된다.
    - 불변 객체 만들기
        - setter 매소드 구현 x
        - class를 상속하지 못하도록 선언(class를 final로 선언하거나 생성자를 private으로 선언)
        - 모든 필드 변수가 final이 아닐 때(가변객체 타입의 필드 변수가 있는 경우)  그 변수에 대해 직접적으로 외부에서 접근하지 못하도록 막음
    - 장점
        - 객체에 대한 신뢰도 상승
        - 멀티쓰레드 환경에서 동기화 처리 없이 객체 공유 가능
    - 단점
        - 객체의 값이 할당될 때마다 새로운 객체가 필요하여 메모리 누수와 성능 저하를 발생시킬 수 있다.
- mutable (가변) 객체
    - ex) List, ArrayList, HasMap, StringBuffer, StringBuilder 등이 있다.
    - 가변 객체를 멀티 쓰레드 환경에서 사용하기 위해서는 별도의 동기화 처리를 해줘야한다.