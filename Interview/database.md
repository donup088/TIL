## 인덱스란?
- DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 오래 걸리기 때문에 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 주는것이다.
- 책에 비유하면 찾아보기 or 색인으로 설명된다.

### 장단점
- 장점
    - 인덱스를 가지고 있기 때문에 SELECT 문장은 매우 빠르게 처리 가능하다.
- 단점
    - 데이터가 저장될 때마다 해당 값을 정렬을 해야하기 때문에 INSERT, UPDATE, DELETE 처리는 느려진다. 
    - 인덱스는 하나의 테이블을 생성해 값을 저장하고 사용하기 때문에 다른 테이블에 의존적인 새로운 테이블이 생성된다.

### 인덱스를 어떻게 설정해야할까?
- 검색에 최적화된 기능이기 때문에 삽입,삭제,수정이 자주 일어나는 비즈니스 로직 or 사용 용도에 따라 인덱스 사용 여부를 고민해야한다.
- 무조건 많이 설정하는 것이 검색 속도 향상을 시켜주진 않는다.
- 데이터베이스 메모리를 사용하여 테이블 형태로 저장되므로 개수와 저장공간은 비례하게된다.
- 조회시 자주 사용하거나 고유한 값을 위주로 인덱스를 설정하는 것이 좋다.
- 인덱스는 테이블당 보통 3~5개가 적당하다.

### 인덱스를 설정난 후 동작과정
1. 인덱스 테이블에서 where 절에 포함된 값을 찾는다.
2. 해당 값의 테이블 pk(ex) id)를 가져온다.
3. 가져온 pk값으로 원본 테이블에서 값을 조회에 온다.
---

### B-Tree 인덱스
- B-Tree는 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지하고 있다. 전문 검색과 같은 특수한 요건이 아닌 경우 대부분 인덱스는 거의 B-Tree 인덱스를 사용한다.
- 구조
    - 최상위에 하나의 루트노드가 존재한고 그 하위에 자식 노드가 붙어있는 구조이다. 트리 구조에 가장 하위에 있는 노드를 리프노드라고 하고 트리구조에서 루트노드,리프노드가 아닌 중간에 있는 노드를 브랜치 노드라고 한다. ex) 루트 노드 -> 브랜치 노드 -> 브랜치 노드 -> 리프 노드
- 인덱스의 리프노드는 항상 실제 데이트 레코드를 찾아가기 위한 주소 값을 가지고 있다.

### B-Tree 인덱스의 가용성과 효용성
- 작업 범위를 결정하는 조건이 많을 수록 쿼리의 처리 성능을 높이지만 체크 조건이 많다고 해서 쿼리의 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 많들 때가 많다.

### B-Tree 인덱스를 사용할 수 없는 대표적인 경우
- NOT-EQUAL 비교("<>","NOT IN", "NOT BETWEEN","IS NOT NULL")
- LIKE '%??' 형태로 문자열 패턴이 비교되는 경우
- 데이터 타입이 서로 다른 비교
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우

### R-Tree 인덱스
- 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스이다. 일반적으로는 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다. 
- 포함관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용할 수 있다.
- Mysql에서는 거리를 비교하는 함수로는 Contains()나 Intersect()를 주로 사용한다.

## 트랜잭션
트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위이다. 트랜잭션은 수행 중에 한 작업이라도 실패하면 롤백되는 원자성을 가지고 있다.
- 원자성(Atomicity)
- 일관성(Consistency)
- 고립성(Isolation)
- 내구성(Durability)

## 트랜잭션 격리 수준
트랜잭션 격리 수준은 트랜잭션의 고립성 레벨에 따른 일관성과 동시성의 트레이드 오프를 조절하는 것이다.
트랜잭션 격리 수준을 높일 수록 일관성이 좋아지지만 동시성을 떨어진다. 이를 판단하여 적용해야한다.

- level 0 Read Uncommitted : 커밋되지 않은 내용에 대해서 데이터를 읽을 수 있다.
    - Dirty Read 발생 : 하나의 트랜잭션이 데이터에 접근하여 값을 A->B로 변경하고 아직 커밋되지 않은 상태에서 다른 트랜잭션이 해당 데이터를 읽으면 B로 읽게된다. 이 때 앞의 트랜잭션이 롤백된다면 뒤에 실행되었던 트랜잭션이 가진 데이터는 꼬이게된다.
    - Non-Repeatable Read 발생
    - Phantom Read 발생

- level 1 Read Committed : 커밋된 내용에 대해서만 데이터를 읽을 수 있다.
    - 대부분의 DBMS가 기본 모드로 채택하고 있다. ex) Oracle, H2 등
    - Non-Repeatable Read 발생 
        - 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리 결과가 다르게 나온다.
    - Phantom Read 발생

- level 2 Repeatable Read : 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 허락하지 않음으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 반환한다.
    - MySQL InnoDB에서 기본으로 채택하고 있다.
    - Phantom Read 발생
        - 한 트랜잭션 안에서 일정범위 레코드를 두 번 이상 읽을 때 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
        - 이를 해결하기 위해서는 트랜잭션 격리 수준을 level 3으로 올려줘야한다.

- level 3 Serializablle Read : 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못하고 중간에 새로운 레코드를 삽입하는 것도 막아주기 때문에 완벽하기 읽기 일관성 모드를 제공한다. 하지만 동시성에 대한 성능은 매우 떨어진다.
    - Read 시에 삽입,수정,삭제 가 동시에 진행될 수 없다.

## RDBMS vs NOSQL
RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스이다. NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장한다. 
- RDBMS
    - Master - slave 구조로 확장한다.
    - 데이터 동기화가 제대로 되지 않을 수 있다.
- NOSQL
    - 분산형 구조 : 데이터를 여러 대의 서버에 분산해 저장하고 분산시 데이터를 상호 복제해 특정 서버에 장애가 발생했을 때도 서비스 중지가 없다.
    - 분산처리와 병렬처리가 가능하다.
    - JOIN에 대한 로직이 필요 없어서 쿼리 로직의 복잡도가 낮다.
    - 기본적으로 JOIN을 지원하지 않기 때문에 복잡한 조인 사용이 없다.
    - 수정이 많이 이루어지지 않은 시스템이 좋고 막대한 데이터를 저장해야 해서 DB를 확장 해야하는 시스템에 적합하다.

## Redis
- 보통 데이터베이스는 하드 디스크나 SSD에 저장한다. 하지만 Redis는 메모리(RAM)에 저장해서 디스크 접근이 필요없어 매우 빠르다. 또한 key-value 형식으로 저장하는 NOSQL DB이다. 싱글쓰레드로 동작한다.
- 캐싱도 가능해서 실시간 채팅에 적합하며 세션 공유를 위해 세션 클러스터링에도 활용된다.
- RAM은 휘발성이기 때문에 이를 방지하기 위해서 백업과정이 존재한다.
    1. 스냅샷 : 특정 지점을 설정하고 디스크에 백업
    2. AOF(Append Only File) : 쿼리들을 저장해두고 서버가 꺼지면 재실행해서 다시 만들어 놓음

## Elastic Search
Elastic Search는 자바로 개발된 오픈소스 검색엔진이다. 보통 단독으로 사용하기 보다는 ELK 스택이라 불리는 Logstash, Kibana 등을 추가적으로 사용한다.

Inverted Index 구조로 데이터를 저장해서 전문(Full-Text) 검색시에 RDBMS보다 뛰어난 성능을 보장한다.

Elastic Search에서 사용하는 Inverted Index는 Elastic Search가 데이터를 저장하기 전에 analyzer가 해당 데이터를 분석하고 tokenizer로 적절히 짤라 키워드를 생성해 inverted index로 저장할 수 있도록 해준다. inverted index는 어떤 단어가 몇번째에 있다는 것을 바로 알 수 있기 때문에 검색에서 좋은 성능을 보인다.
ex)
```
token       id
나는        1,3,5,6
우리는      2,4
책          1,5
```
