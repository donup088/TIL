## 트랜잭션

### 트랜잭션 ACID
원자성: 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하거나 실패해야한다.
일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야한다.
격리성: 동시에 실행되는 트랙잭션들이 서로에게 영향을 미치지 않도록 격리한다.
지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.

### DB 연결 구조와 DB 세션
- 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺는다. 이때 데이터베이스 서버는 내부에 세션이라는 것을 만든다. 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.
- 커넥션 풀이 10개의 커넥션을 생성하면 세션도 10개 만들어진다.

### DB 락
세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데 세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 생긴다. 이런 문제를 방지하려면 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안 커밋이나 롤백 전까지는 다른 세션에서 해당 데이터를 수정할 수 없게 막아야한다.

예시 상황
1. 세션1 트랜잭션 시작 
2. 해당 row의 락을 먼저 획득, 락이 남아있으므로 세션1은 락을 획득한다.
3. 세션1은 락을 획득했으므로 해당 row에 update sql을 수행한다.
4. 세션2 트랜잭션 시작
5. 세션2는 해당 row의 락이 없으므로 락이 돌아올 때까지 대기한다.
6. 이때 무한정 대기하는 것은 아니다. 락 대기 시간을 넘어가면 락 타임아웃 오류가 발생한다.
7. 세션1이 커밋을 수행하면 트랜잭션이 종료되었으므로 락도 반납한다.

일반적인 조회에서는 락을 사용하지 않는다. 하지만 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 이럴 때는 select for update 구문을 사용하면 된다.

### 트랜잭션 적용
트랜잭션을 시작하려면 커넥션이 필요하다. 서비스 계층에서 커넥션을 만들고 트랜잭션 커밋 이후에 커넥션을 종료해야한다. 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지 해야한다. 그래야 같은 DB 세션을 사용할 수 있다.