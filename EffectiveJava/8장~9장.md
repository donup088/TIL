## 매개변수가 유효한지 검사하라.
- 메서드 바디 실행 전에 매개변수 유효성을 검사해야한다.
- 메서드나 생성자를 작성할 때 매개변수들에 어떤 제약이 있을 지 생각해야한다.
- 메서드 바디가 실행된 후 매개변수 유효성을 검사하는 경우 오류를 찾기 힘들어질 수 있다.
- 매개변수 유효성은 코드가 시작되는 부분에서 명시적으로 검사하는 것이 좋다.   


## 적시에 방어적 복사본을 만들라.
- Date는 새로운 코드를 작성할 때 사용하지 말고 LocalDateTime이나 ZonedDateTime을 사용하자. Date는 오래된 API 이기 때문에 가변으로 되어있다.
  
## 메서드 시그니처를 신중히 설계하라.
- 메서드 이름을 신중히 짓자.
    - 같은 패키지에 속한 다른 이름들과 일관되게 짓고 긴 이름은 피하자.
- 편의 메서드를 너무 많이 만들지 말자.
    - 메서드가 너무 많으면 유지보수하기 힘들어진다.
    - 자주 쓰이는 경우에만 만들자.
- 매개변수 목록은 짧게 유지하자.
    - 같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 좋지 않다.
    - 매개변수가 많아지는 경우 클래스를 만들어서 정적 멤버 클래스로 두자.

## 다중 정의(오버로딩)는 신중히 사용하라.
- 오버로딩된 매서드들은 컴파일타임에 어느 메서드를 호출할지 정해지기 때문에 예상된 결과와 다르게 나올 수 있다. 
- 오버로딩을 사용해서 혼동을 일으키는 상황은 피해야한다. 매개변수 수가 같은 오버로딩은 피하는 것이 좋다.

## null이 아닌 빈 컬렉션이나 배열을 반환하라.
- null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다.

## 지역변수의 범위를 최소화하라.
- 지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
- 가장 처음 쓰일 때 선언하는 것이 좋다. 그리고 지역변수는 선언과 동시에 초기화해야한다.
- 메서드를 작게 유지하고 한 가지 기능에 집중하게 되면 지역변수 범위를 최소화시킬 수 있다.
- 반복문의 변수 값을 반복문이후에도 사용하는 것이 아니라면 while문보다 for문을 사용하는 것이 좋다.

## 전통적인 for 문보다는 for-each 문을 사용하라.
- for문을 사용해야하는 경우
    - 리스트의 반복자나 배열의 인덱스를 사용하는 경우 
    - 반복되는 횟수를 사용하는 경우
- for문을 꼭 사용해야하는 경우가 아니라면 for-each문을 사용하자
- for-each문은 for문보다 명료하고 유연하며 버그를 예방해준다.

## 라이브러리를 익히고 사용하라.
- 장점
    1. 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 다른 프로그래머들의 경험을 활용할 수 있다.
    2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
    3. 따로 노력하지 않아도 성능이 지속해서 개선된다.
    4. 기능이 점점많아진다.
    5. 작성한 코드가 많은 사람에게 낯익은 코드가 된다. 이로 인해 읽기 좋고 유지보수하기 좋고 재사용하기 좋은 코드가 된다.
- Random 을 사용하지 않고 ThreadLocalRendom으로 대체하면 잘 작동한다.
- java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야한다.

## 정확한 답이 필요하다면 float와 double은 피하라.
- float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다. 금융계산에는 BigDecimal, int, long을 사용해야한다.
- 성능에 신경쓰지 않는다면 BigDecimal을 사용하고 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int를 사용하고 18자리 십진수로 표현할 수 있다면 long을 사용하자. 18자리를 넘어가야하면 BigDecimal을 사용해야한다.

## 박싱된 기본 타입보다는 기본 타입을 사용하라.
- 기본 타입 : int, double, boolean
- 박싱된 기본 타입 : Integer, Double, Boolean
- 기본 타입 vs 박싱된 기본 타입
    - 차이점
        1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값과 식별성이란 속성을 갖는다. 따라서 박싱된 기본 타입은 값이 같아도 서로 다르다고 식별될 수 있다. 박싱된 기본 타입에 == 연산자를 사용하면 오류가 발생한다.
        ```
        // 박싱된 기본타입에 == 연산자를 사용하면 
        // 첫번째로는 정수 값을 비교하고
        // 두번째로는 두 객체 참조의 식별성을 검사하게 된다.
        // 따라서 서로 다르다는 결과가 나오게된다.
        new Integer(42) vs new Integer(42) 
        ```
        2. 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 null을 가질 수 있다.
        3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 효율적이다.
- 박싱된 기본 타입을 사용하는 경우
    1. 컬렉션의 원소, 키, 값으로 사용한다. 컬렉션은 기본타입을 담을 수 없으므로 박싱된 기본 타입을 사용해야한다.
    2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야한다.

## 문자열 연결은 느리니 주의하라.
- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.
- 성능에 신경 써야 한다면 많은 무자열을 연결할 때는 문자열 연결 연산자를 피하고 StringBuilder의 append 메서드를 사용하자.

## 객체는 인터페이스를 사용해 참조하라.
```
Set<Son> sonSet= new LinkedHashSet<>(); //이처럼 인터페이스 타입으로 사용
```
- 인터페이스를 타입으로 사용하면 프로그램이 훨씬 유연해진다.
- 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자.

## 리플렉션보다는 인터페이스를 사용하라.
- 리플렉션이란 무엇인가...?
    - 리플렉션은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API
    - 왜 사용할까?
        - 동적으로 클래스를 사용해야 할 때 필요하다. 작성 시점에는 어떤 클래스를 사용해야하는 지 모르는 경우, 런타임 시점에서 클래스를 가져와서 실행해야하는 경우에 사용한다.
    - 어디에 사용될까?
        - 애플리케이션 개발보다는 프레임워크, 라이브러리에서 많이 사용된다. 
    - 어떻게 가능할까?
        - 자바 클래스 파일은 프로그램 생성시 힙영역에 저장되고 클래스 이름만 알고 있다면 이 영역에 들어가서 클래스의 정보를 가져올 수 있다.
    - 단점
        - 리플렉션을 사용한 코드는 성능이 안좋다.
        - 리플렉션을 이용하여 개발한 프로그램은 에러가 발생하기 쉽고 디버깅이 어렵다.
        - 리플렉션을 사용한 코드는 복잡하다.
- 컴파일타임에 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야한다. 되도록 객체 생성에만 사용하고 생성한 객체를 이용할 때는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해 사용해야한다.