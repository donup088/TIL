## 생성자 대신 정적 팩터리 매서드를 고려하라.
- 정적 팩토리 메서드가 생성자 보다 좋은 점
    1. 이름을 가질 수 있다.
    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 단점
    1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 매서드만 제공하면 하위 클래스를 만들 수 없다.
    2. 정적 팩터리 매서드는 프로그래머가 찾기 어렵다.


## 생성자에 매개변수가 많다면 빌더를 고려하라.
- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패던을 선택하는 것이 좋다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간력하고 자바빈즈보다 훨씬 안전하다.

## 불필요한 객체 생성을 피하라.
- 불필요한 오토박싱을 없애야한다.
```
private static long sum(){
    Long sum= 0L;
    for(long i=0;i<=Integer.MAX_VALUE; i++)
        sum+=i;
    return sum;
}
```
- Long sum 을 long sum으로 고침으로써 성능을 더욱 좋아지게 만들 수 있다.

## try-finally 대신 try-with-resources를 사용하자.
- 코드는 짧고 분명해지고 예외정보도 훨씬 유용하다.

## toString을 항상 재정의하라.
- toString을 잘 구현한 클래스는 이 클래스를 사용한 시스템의 디버깅이 쉬워진다.

## equals를 재정의하려거든 hashcode도 재정의하라.
- equals 사용 : 2개의 객체가 동일한지 검사하기 위해 사용된다. 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동일한 객체가 된다. 동일한 문자열 2개를 생성하면 2개의 문자열은 서로 다른 메모리에 할당된다. 하지만 String 클래스에서 equals 메서드를 오버라이드하여 문자를 비교하는 코드를 추가했기 때문에 2개의 문자열을 비교하기 위해 equals를 사용하면 true가 나오게된다.
- hashcode : 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴한다. 따라서 객체마다 다른 값을 가지고 있다. 
- HashTable
    - key, value 형태로 데이터를 저장한다. 이 때 해시함수를 이용하여 key 값을 기준으로 고유한 식별값인 해시값을 만든다. 이 해시값을 버킷에 저장한다.
    - HashTable의 크기는 한정적이기 때문에 서로 다른 객체라 하더라도 같은 해시값을 갖을 수 있다. 이러한 경우 해시충돌이 일어나고 해당 버킷에 LinkedList 형태로 객체를 추가한다.
        - HashTable에 put 메서드로 객체를 추가하는 경우
            - 값이 같은 객체가 있다면 기존 객체를 덮어쓴다.
            - 값이 같은 객체가 없다면 해당 entry를 LinkedList에 추가한다.
        - get 메서드로 객체를 조회하는 경우
            - 값이 같은 객체가 있다면 그 객체를 리턴한다.(해시값이 다르다면 equals 비교는 수행되지 않는다.)
            - 값이 같은 객체가 없다면 null을 리턴한다.
- hashcode()를 재정의하지 않으면 같은 값 객체라도 해시값이 다를 수 있다. 따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.
- equals()를 재정의하지않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷은 찾을 수 있지만 해당객체가 자신과 같은 객체인지 값을 비교할 수 없다. 

