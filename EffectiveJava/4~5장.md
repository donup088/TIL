### 클래스와 멤버의 접근 권한을 최소화하라.
- 정보은닉의 장점
    - 시스템 개발 속도를 높인다. 
    - 시스템 관리 비용을 낮춘다.
    - 성능최적화에 도움을 준다.
    - 소프트웨어 재사용성을 높인다.
- 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
- 과정
    1. 공개 API를 설계한 후 모든 멤버는 private으로 만든다. 
    2. 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 package-private으로 풀어준다.

### 변경 가능성을 최소화하라.
- 불변 클래스를 사용하자. ex)String, BigInteger, BigDecimal
- 불변 클래스를 사용하면 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며 오류가 생길 여지도 적고 안전하다.
- Getter가 있다고 해서 Setter를 사용하면 안된다. 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

### 상속보다는 컴포지션을 사용하라.
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.#
- 기존 클래시를 확장하는 대신 새로운 클래스를 만들고 참조하게 하자. 기존 클래스를 새로운 클래스의 구성요소로 쓰이게 하는 것으로 컴포지션이라 한다.
- 클래스 B가 클래스 is-a 관계일 때만 클래스 A를 상속해야한다. 클래스 A를 상속하는 클래스 B를 작성하려 한다면 주의하자.
- 래퍼클래스로 감싸고 있는 기본 타입은 외부에서 변경할 수 없다. 값을 변경하고 싶다면 새로운 포장객체를 만들어야한다. 래퍼클래스 견고하고 강력하기 때문에 사용하는 것이 좋다. 성능에도 크게 문제가 안된다고 한다.

### 태그 달린 클래스보다는 클래스 계층구조를 활용하라.
- 태그 달린 클래스에는 새로운 의미가 추가될 때마다 switch 문을 찾아 새 의미를 처리하는 코드를 작성해야한다. 태그 달린 클래스는 장황하고 오류를 내기 쉽고 비효율적이다.
- 태그를 없애고 계층구조로 리팩토링하는 것을 생각하자. 독립된 클래스를 만들고 root abstract class를 확장하는 구조로 만들 수 있다.
```
abstract class Figure{
    ...
}

class Circle extends Figure{
    ...
}

class Rectangle extends Figure{
    ...
}
```

### raw 타입을 사용하지 말라
- List<E>의 raw 타입은 List이다. List<String> 이라고 하면 String만 List에 들어갈 수 있는데 List 라고 raw 타입을 사용하면 String 이외에 다른 것을 넣어도 컴파일이 되고 실행된다. 모든 오류는 컴파일할 때 발견하는 것이 좋다. 이러한 오류는 런타임에 알 수 있는데 오류를 찾기 위해 코드 전체를 살펴봐야 할 수도 있다.
- raw 타입을 사용하면 제네릭이 주는 안전성과 표현력을 잃게 된다.
- 제네릭 타입을 사용하고 싶지만 타입 매개변수가 무엇인지 신경쓰고 싶지 않을 때는 ?를 사용하자.
- raw타입을 사용해도 괜찮을 때로는 instanceof를 사용할 때가 있다.

### 비검사 경고를 제거하라.
```
//Set<Lark> exaltation=new HashSet();
//Set<Lark> exaltation=new HashSet<>();
```
- 가능한 모든 비검사 경고를 제거해야한다. 이로써 타입 안전성이 보장된다.
- 경고를 제거할 수 없지만 타입이 안전하다고 확신할 수 있다면 @SuppressWarings("unchecked") 애노테이션을 달아 경고를 숨기자. @SuppressWarings를 사용한다면 가능한 좁은 범위에 적용하자. 그리고 경고를 무시해도 안전한 이유를 주석으로 남겨야한다.

### 배열보다는 리스트를 사용하라
```
List<Object> objectArr=new Long[1];
objectArr[0]="타입이 달라 넣을 수 없다";
```
- 리스트를 사용하면 Long용 리스트에 String을 넣을 수 없어서 컴파일 할 때 바로 알 수 있다. 하지만 배열을 사용하면 런타임에 오류를 알게된다.
